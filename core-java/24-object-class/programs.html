<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>object-class-programs</title>
		<!-- font awesome -->
		<link rel="stylesheet" href="./fontawesome-free-6.2.1-web/css/all.css" />
		<link
			rel="stylesheet"
			type="text/css"
			href="./google-code-prettify/prettify.css"
		/>
		<style>
			/* Background color style */
			pre.prettyprint {
				background-color: #eee;
				padding: 2px;
				border: 1px solid #888;
			}
		</style>
		<!-- styles -->
		<link rel="stylesheet" href="./styles.css" />
	</head>
	<body onload="PR.prettyPrint()">
		<!-- navigation button -->
		<span class="resource-nav-btn" id="resource-nav-btn">
			<i class="fa-sharp fa-solid fa-bars fa-2x" style="color: #000"></i>
		</span>

		<!-- navigation bar -->
		<nav class="resource-navbar" id="resource-navbar">
			<div class="resource-navbar-header">
				<span class="resource-nav-close" id="resource-nav-close">
					<i class="fa-sharp fa-solid fa-xmark fa-1.5x" style="color: #000"></i>
				</span>
			</div>
			<ul class="resource-nav-items">
				<span class="resource-navbar-links">Resources Navigator</span>
				<br />

				<li><a href="./index.html" class="resource-nav-link">notes</a></li>
				<li>
					<a href="./programs.html" class="resource-nav-link">programs</a>
				</li>
				<li><a href="./points.html" class="resource-nav-link">points</a></li>
				<li>
					<a href="./interview-qa.html" class="resource-nav-link"
						>interview QA</a
					>
				</li>
				<li>
					<a href="./assignment-qa.html" class="resource-nav-link"
						>assignment QA</a
					>
				</li>
			</ul>
		</nav>

		<span class="main-nav-btn" id="main-nav-btn">
			<i class="fa-sharp fa-solid fa-bars fa-2x" style="color: #000"></i>
		</span>

		<!-- main navigator -->
		<nav class="main-navbar" id="main-navbar">
			<div class="main-navbar-header">
				<span class="main-nav-close" id="main-nav-close">
					<i class="fa-sharp fa-solid fa-xmark fa-1.5x" style="color: #000"></i>
				</span>
				<!-- main navigation button -->
			</div>
			<ul class="main-nav-items">
				<span class="main-navbar-links">Main Navigator</span>
				<br />
				<li>
					<a href="index.html" class="main-nav-link">Language Fundamentals</a>
				</li>
				<li><a href="about.html" class="main-nav-link">static-members</a></li>
				<li>
					<a href="work.html" class="main-nav-link">non-static-members</a>
				</li>
				<li><a href="contact.html" class="main-nav-link">inheritance</a></li>
				<li><a href="index.html" class="main-nav-link">scanner-class</a></li>
				<li><a href="about.html" class="main-nav-link">objects-count</a></li>
				<li>
					<a href="work.html" class="main-nav-link"
						>packages-and-access-levels</a
					>
				</li>
				<li><a href="contact.html" class="main-nav-link">encapsulation</a></li>
				<li><a href="index.html" class="main-nav-link">type-casting</a></li>
				<li><a href="about.html" class="main-nav-link">polymorphism</a></li>
				<li>
					<a href="work.html" class="main-nav-link">super-this-in-methods</a>
				</li>
				<li><a href="contact.html" class="main-nav-link">abstraction</a></li>
				<li><a href="index.html" class="main-nav-link">interfaces</a></li>
				<li>
					<a href="about.html" class="main-nav-link">command-line-arguments</a>
				</li>
				<li><a href="work.html" class="main-nav-link">final-keyword</a></li>
				<li>
					<a href="contact.html" class="main-nav-link">exception-handling</a>
				</li>
				<li><a href="index.html" class="main-nav-link">assertion</a></li>
				<li><a href="about.html" class="main-nav-link">enum</a></li>
				<li><a href="work.html" class="main-nav-link">wrapper-classes</a></li>
				<li><a href="contact.html" class="main-nav-link">string</a></li>
				<li>
					<a href="index.html" class="main-nav-link"
						>string-buffer-and-string-builder</a
					>
				</li>
				<li><a href="about.html" class="main-nav-link">multi-threads</a></li>
				<li><a href="work.html" class="main-nav-link">object-class</a></li>
				<li><a href="contact.html" class="main-nav-link">Generics</a></li>
				<li><a href="index.html" class="main-nav-link">collection-API</a></li>
				<li><a href="about.html" class="main-nav-link">File-Handling</a></li>
				<li><a href="work.html" class="main-nav-link">Annotations</a></li>
				<li>
					<a href="contact.html" class="main-nav-link">Java-8.0-Features</a>
				</li>
			</ul>
		</nav>

		<!-- header -->
		<header class="header">
			<div class="banner">
				<h1 class="banner-title">Object class in java - programs</h1>
			</div>
		</header>

		<!-- end of header -->
		<!-- content-divider -->
		<div class="content-divider"></div>
		<!-- end of content divider -->
<br />
<article class="topic app">
<h2>app1</h2>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 1</h3>
<pre class="prettyprint linenums">
class A
{
	String name;
	int rollno;
	
	A(String name, int rollno)
	{
		this.name = name;
		this.rollno = rollno;
	} 

	public String toString()
	{
		return name + " : " + rollno;
	}
}
class M1
{
	public static void main(String[] args) 
	{
		A a1 = new A("vijay", 101);
		A a2 = new A("adam", 102);
		System.out.println(a1);
		System.out.println(a2);
	}
}
/*
1. toString() we can use this method to get the string representation of an object
2. whenever we call object reference internally calling the toString method
3. toString method returns class name @ hascode in the form of hexadecimal
4. in all the wrapper classes,collection classes and in String class, String Buffer and String Builder classes 
   toString method got overrided to return the object's content.
5. for every object a unique code will be generated by the JVM it is called hashCode
6. hashcode doent represent address of object
   JVM will use hashcode while saving objects into hashing related datastructures like hashtable,
   hashMap, hashSet etc.
7. The main advantage of saving objects based on hashcode is search operation will become easy
(the most powerful algorith is hashing).
8.If we allow to execute hashCode method of object class then it will generate hashCode based on
address of the object.it doesnt mean that hashcode represents address of the object.
9. we can override hashcode to generate our own hashcode.
10.it is only proper when for every object if we generate a unique number as hashcode.
11. equals method used to check equality of two object
12. if our class doenst contain equals method then object class equals method will be executed.
13. by default object class equals method compares the object reference not the content.
14. String class equals method overrided to compare the content not the reference.
*/
 
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 2</h3>
<pre class="prettyprint linenums">
import java.lang.reflect.*;
class M2
{
	public static void main(String[] args) throws Exception
	{
		int count = 0;
		Class c = Class.forName("java.lang.Object");
		Method[] m = c.getDeclaredMethods();
		for(Method m1 : m)
		{
			count++;
			System.out.println(m1.getName());
		}
		System.out.println("The number of methods:" + count);
	}
}
/*
1.public String toString()
2.public native int hashCode()
3.public boolean equals(Object o)
4.protected native Object clone() throws CloneNotSupportedException
5.protected void finalize() throws Throwable
6.public final Class getClass()
7.public final void wait() throws InterruptedException
8.public final native void wait(long ms) throws InterruptedException
9.public final native void wait(long ms, int ns) throws InterruptedException
10.public final native void notify()
11.public final native void notifyAll()
12.private static native void registerNatives() - this method used internally by the object class
and not available to the child classes hence we are considering this method
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 3</h3>
<pre class="prettyprint linenums">
class E
{
	int i;

	public String toString()
	{
		return "" + this.i;
	}
}
class M3
{
	public static void main(String[] args)
	{
		E e1 = new E();
		e1.i = 10;
		E e2 = new E();
		e2.i = 20;
		System.out.println(e1);//address of the object instead of content
		System.out.println(e2);//hexadecimal repr of mem address
	}
}
/*
1.for all the java classes the most commonly required methods are defined in a separate class i,e object class.
2. if the class doesnt extends any other class then it is the direct child class of object class
if the class is already extends another class it is the indirect child class of object class.
3. object class contains totally 11 methods
*/
  
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 4</h3>
<pre class="prettyprint linenums">
class F
{
	int i;

	public String toString()
	{
		return "its a type object with i value as: " + i;
	}
}
class M4
{
	public static void main(String[] args) 
	{
		F f1 = new F();
		f1.i = 20;
		System.out.println(f1);
	}
}
/*
1. in this case we will be getting
the content of the object rather than the memory address.
2. We usually dont worry about the memory address only the content that matters.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 5</h3>
<pre class="prettyprint linenums">
class G
{
	int i;
	public String toString()
	{
		return "its a type object with i value as :" + i;
	}
}
class M5
{
	public static void main(String[] args) 
	{
		G g1 = new G();
		g1.i = 20;
		System.out.println(g1);
		String s1 = "description: " + g1 + g1 + g1;
		System.out.println(s1);
	}
}
/*
1. whenever reference variable adding to the string, from the reference variable toString method is calling.
2. By default object class toString method printing address of the object rather than content(state) of the object.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 6</h3>
<pre class="prettyprint linenums">
class B
{
	int i, j;

	B(int k, int l)
	{
		this.i = k;
		this.j = l;
	}

	public String toString()
	{
		return i + ":" + j;
	}
}
class M6
{
	public static void main(String[] args) 
	{
		B b1 = new B(10, 20);
		System.out.println(b1);
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 7</h3>
<pre class="prettyprint linenums">
class C
{
	int i;

	public String toString()
	{
		return "i = " + i;
	}
}
class D
{
	int j;
	C c_ref;

	public String toString()
	{
		return "j = " + j + ", " + c_ref;
	}
}
class M7  
{
	public static void main(String[] args) 
	{
		C c1 = new C();
		c1.i = 10;
		D d1 = new D();
		d1.j = 20;
		d1.c_ref = c1;
		System.out.println(c1);
		System.out.println(d1);
	}
}
/*
1."has a" relationship D has C type, C class contains one attribute, D class contains two attributes.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 8</h3>
<pre class="prettyprint linenums">
import java.util.ArrayList;
class M8 
{
	public static void main(String[] args) 
	{
		String s1 = "Hello";
		Integer obj = 10;
		Thread t1 = new Thread();
		ArrayList list = new ArrayList();
		System.out.println(s1);
		System.out.println(obj);
		System.out.println(t1);
		System.out.println(list);
	}
}
/*
1. In all these classes toString method of object class got overrided to return the content instead of the memory address.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<br />
<article class="topic app">
<h2>app2</h2>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 9</h3>
<pre class="prettyprint linenums">
class G
{
	int i;

	public boolean equals(Object obj)
	{
		return this.i == ((G)obj).i;
	}
}
class M10
{
	public static void main(String[] args) 
	{
		G g1 = new G();		
		g1.i = 10;

		G g2 = new G();
		g2.i = 10;

		System.out.println(g1 == g2);
		System.out.println(g1.equals(g2));

		G g3 = g1;

		System.out.println(g3 == g1);
		System.out.println(g3.equals(g1));
	}
}
/*
1. "==" operator always checking for the memory location.if both reference pointing to same object == operator returns true
2. if both the references pointing to different object returns false.
3. By default equals method compares two references. Object obj is g2.i and i is this.i. how to use equals method in our class i,e, we can use == operator between attributes.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 10</h3>
<pre class="prettyprint linenums">
class A
{
	int i;
}
class M11
{
	public static void main(String[] args) 
	{
		A a1 = new A();
		a1.i = 10;

		A a2 = new A();
		a2.i = 10;

		System.out.println(a1 == a2);
		System.out.println(a1.equals(a2));
		System.out.println(a1.i == a2.i);
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 11</h3>
<pre class="prettyprint linenums">
class L
{
	int i;
}
class M12
{
	public static void main(String[] args) 
	{
		L l1 = new L();
		l1.i = 10;

		L l2 = new L();
		l2.i = 10;

		System.out.println(l1 == l2);
		System.out.println(l1.equals(l2));
		System.out.println(l1.i == l2.i);

		L l3 = l1;
		System.out.println(l1 == l3);
		System.out.println(l1.equals(l3));
		System.out.println(l1.i == l3.i);
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 12</h3>
<pre class="prettyprint linenums">
class B
{
	int i;
	double j;
	B(int i, double j)
	{
		this.i = i;
		this.j = j;
	}
}
class M13 
{
	public static void main(String[] args) 
	{
		B b1 = new B(10, 2.5);
		B b2 = new B(10, 2.5);
		
		B b3 = b2;

		System.out.println(b1 == b2);
		System.out.println(b1.equals(b2));
		//attribute by attribute compararing the content
		System.out.println(b1.i == b2.i && b1.j == b2.j);

		System.out.println(b2 == b3);
		System.out.println(b2.equals(b3));
		System.out.println(b2.i == b3.i && b2.j == b3.j);
	}
}

/*
skeleton of object class equals method
class Object
{
	public boolean equals(Object obj)
	{
		return (this == obj);
	}
}
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 13</h3>
<pre class="prettyprint linenums">
class C
{
	int i;

	C(int i)
	{
		this.i = i;
	}

	public boolean equals(Object obj)
	{
		return (this.i == ((C)obj).i);
	}
}
class M14
{
	public static void main(String[] args) 
	{
		C c1 = new C(90);
		C c2 = new C(90);
		System.out.println(c1 == c2);
		System.out.println(c1.equals(c2));
		System.out.println(c1.i == c2.i);
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 14</h3>
<pre class="prettyprint linenums">
class D
{
	int i;
	int j;

	D(int i, int j)
	{
		this.i = i;
		this.j = j;
	}

	public boolean equals(Object obj)
	{
		return (this.i == ((D)obj).i && this.j == ((D)obj).j);
	}
}
class M15
{
	public static void main(String[] args) 
	{
		D d1 = new D(90, 10);	
		D d2 = new D(90, 1);
		System.out.println(d1 == d2);
		System.out.println(d1.equals(d2));
		System.out.println(d1.i == d2.i && d1.j == d2.j);
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 15</h3>
<pre class="prettyprint linenums">
class E
{
	int i;
	int j;
	double k;

	E(int i, int j, double k)
	{
		this.i = i;
		this.j = j;
		this.k = k;
	}

	public boolean equals(Object obj)
	{
		E ref = (E)obj;
		return (i == ref.i && j == ref.j && k == ref.k);
		
	}
}
class M16
{
	public static void main(String[] args) 
	{
		E e1 = new E(10, 20, 5.8);
		E e2 = new E(10, 20, 5.5);
		E e3 = new E(10, 20, 5.9);
		System.out.println(e1.equals(e2));
		System.out.println(e1.equals(e3));
		System.out.println(e2.equals(e3));
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 16</h3>
<pre class="prettyprint linenums">
class N 
{
	int i;

	N(int i)
	{
		this.i = i;
	}

	public boolean equals(Object obj)
	{
		N ref = (N) obj;//downcasting obj into N
		return i == ref.i;
	}
}
class M extends N 
{
	int i;

	M()
	{
		super(90);
	}
}
class M17 
{
	public static void main(String[] args) 
	{
		N n1 = new N(90);
		N n2 = new N(90);
	
		M m1 = new M();
		m1.i = 90;
		System.out.println(n1.equals(n2));
		//we get classcastexception bcz
		  //String,Integer,boolean are not subclass to N so we get Exception
		//CTS bcz equals method arg type is object type
		//class M is also subclass to object type
		//it automaticaly upcast
		System.out.println(n1.equals(m1));
		//can supply string
		//System.out.println(n1.equals("xyz"));
		//can supply any wrapper object
		//90 is boxing into Integer object
		//Integer object is upcasted into Object type
		//System.out.println(n1.equals(90));
		//System.out.println(n1.equals(true));
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 17</h3>
<pre class="prettyprint linenums">
class F
{
	int i;

	F(int i)
	{
		this.i = i;
	}
	public boolean equals(Object obj)
	{
       //to avoid this we can first get suggestion from instance of operatror
		//if(! (obj instanceof F))
		//{
		//	return false;
		//}
		//F ref = (F) obj;//downcasting obj into F
		if(obj instanceof O)
		{
			O ref = (O)obj;
			return this.i == ref.i;
		}
		if(obj instanceof P)
		{
			P ref = (P) obj;
			return this.i == ref.i;
		}
		return false;
	}
	
}
class O 
{
	int i;
}
class P
{
	int i;
}
class M18 
{
	public static void main(String[] args) 
	{
		F f1 = new F(900);
		F f2 = new F(900);
	
		O o1 = new O();
		o1.i = 900;

		P p1 = new P();
		p1.i = 900;
		//System.out.println(f1.equals(f2));
		System.out.println(f1.equals(o1));
		System.out.println(f1.equals(p1));
		System.out.println(f1.equals("xyz"));
		//System.out.println(f1.equals(90));
		//System.out.println(f1.equals(true));
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 18</h3>
<pre class="prettyprint linenums">
class P
{
	int i;
}
class Q
{
	int i;
	Q(int i)
	{
		this.i = i;
	}
}
class R 
{
	int i;
	R(int i)
	{
		this.i = i;
	}
	public boolean equals(Object obj)
	{
		//if only first operand returns true then only checks second
		return (obj instanceof R && this.i == ((R)obj).i);
		//return this.i == ((R)obj).i;
	}
}
class M19
{
	public static void main(String[] args) 
	{
		R r1 = new R(90);
		R r2 = new R(90);
		Q q1 = new Q(90);
	
		P p1 = new P();
		p1.i = 90;
	//we suppose to get exception but we get false bcz of instanceof operator
		System.out.println(r1.equals(r2));
		System.out.println(r1.equals(q1));
	//we suppose to get exception but we get false bcz of instanceof operator
		System.out.println(r1.equals(p1));
	//we suppose to get exception but we get false bcz of instanceof operator
		System.out.println(r1.equals(90));
	//we suppose to get exception but we get false bcz of instanceof operator
		System.out.println(r1.equals(90.0));
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 19</h3>
<pre class="prettyprint linenums">
class H
{
	int i, j, k;
	H(int i, int j, int k)
	{
		this.i = i;
		this.j = j;
		this.k = k;
	}
	public boolean equals(Object obj)
	{
		//if only first operand returns true then only checks second
		return (obj instanceof H) &&
			    i == ((H)obj).i &&
			    j == ((H)obj).j &&
			    k == ((H)obj).k;
	}
}
class M20
{
	public static void main(String[] args) 
	{
		H h1 = new H(10, 20, 30);
		H h2 = new H(10, 20, 30);
	
		System.out.println(h1.equals(h2));
		System.out.println(h1.equals(10));
		System.out.println(h1.equals(new H(10, 20, 30)));
		System.out.println(h1.equals(new H(10, 20, 31)));
		System.out.println(h1.equals("hello"));
	}
}
/*
it will check whether the object type is H type or not
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 20</h3>
<pre class="prettyprint linenums">
class M21 
{
	public static void main(String[] args) 
	{
		String s1 = "hello";
		String s2 = "hello";
		String s3 = new String("hell");

		System.out.println(s1.equals(s2));
		System.out.println(s1.equals(s3));
		System.out.println(s2.equals(s3));
	}
}
/*
inside String class already equals method got overrided to check the content.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 21</h3>
<pre class="prettyprint linenums">
class M22 
{
	public static void main(String[] args) 
	{
		Integer obj1 = new Integer(90);
		Integer obj2 = new Integer(90);
		Integer obj3 = 90;

		System.out.println(obj1.equals(obj2));
		System.out.println(obj1.equals(obj3));
		System.out.println(obj2.equals(obj3));
	}
}
/*
in all the 8 wrapper classes equals method got overrided to compare content.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 22</h3>
<pre class="prettyprint linenums">
class M23 
{
	public static void main(String[] args) 
	{
		StringBuffer sb1 = new StringBuffer("hello");
		StringBuffer sb2 = new StringBuffer("hello");
		System.out.println(sb1.equals(sb2));
	}
}
/*
- in stringBuffer class only toString method got overrided to return the content
but not equals method to compare the content. its using object class equals 
method only.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 23</h3>
<pre class="prettyprint linenums">
class M24 
{
	public static void main(String[] args) 
	{
		StringBuilder sb1 = new StringBuilder("hello");
		StringBuilder sb2 = new StringBuilder("hello");
		System.out.println(sb1.equals(sb2));
	}
}
/*
same with StringBuilder like StringBuffer class.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 24</h3>
<pre class="prettyprint linenums">
import java.util.ArrayList;
class M25 
{
	public static void main(String[] args) 
	{
		ArrayList<Integer> list1 = new ArrayList<Integer>();
		list1.add(90);
		list1.add(910);
		list1.add(190);


		ArrayList<Integer> list2 = new ArrayList<Integer>();
		list2.add(90);
		list2.add(910);
		list2.add(190);

		System.out.println(list1.equals(list2));
	}
}
/*
- in all the collection API classes equals method got
overrided to check the contents of the objects.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 25</h3>
<pre class="prettyprint linenums">
class I
{
	int x;//primitive
	String s1;//String type

	public boolean equals(Object obj)
	{
		//in string class already equals method got overrided to check the content
		return (obj instanceof I) && (x == ((I)obj).x) && 
			(s1.equals(((I)obj).s1));
	}
}
class M26 
{
	public static void main(String[] args) 
	{
		I i1 = new I();
		i1.x = 10;
		i1.s1 = "hello";

		I i2 = new I();
		i2.x = 10;
		i2.s1 = "hello";

		//if any one attribute changes returns false
		System.out.println(i1.equals(i2));

		I i3 = new I();
		//in this case i3.x values is 0 i3.s1 value is null
		System.out.println(i3.equals(i1));

		//s1 is null
		I i4 = new I();
		i4.x = 10;
		//i4.s1 is null from a null calling equals method
		  //we get NullPointerException
		System.out.println(i4.equals(i1));

	}
}
/*
- initialy checking whether obj is current class type or
not. this.x comparing with argument.x and this.s1 comparing with
argument.s1. inside string class equals method already got
overrided to check the content, so this.s1 is a string and
argument.s1 is also a string. If any attribute is changed we get 
the false.

-while creating an object
to i3 initialy x value is 0, s1 value null we tried to call
equals method on null, so in this case we will be getting the 
null pointer exception
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 26</h3>
<pre class="prettyprint linenums">
class J
{
	int x;//primitive
	String s1;//String type

	public boolean equals(Object obj)
	{
		boolean flag = (obj instanceof J) &&
					   (x == ((J)obj).x) &&
					   (
							s1 == null ?
							(((J)obj).s1 == null ? true : false) :
							(((J)obj).s1 == null ? false : s1.equals(((J)obj).s1)) 
					   );
		return flag;
	}
}
class M27 
{
	public static void main(String[] args) 
	{
		J j1 = new J();
		j1.x = 10;
		j1.s1 = "hello";

		J j2 = new J();
		j2.x = 10;
		j2.s1 = "hello";
		
		J j3 = new J();

		j3.x = 10;

		J j4 = new J();

		j4.x = 10;

		System.out.println(j1.equals(j2));
		System.out.println(j1.equals(j3));
		System.out.println(j2.equals(j3));
		System.out.println(j3.equals(j2));
		System.out.println(j2.equals(j1));
		System.out.println(j3.equals(j4));
	}
}
/*
1. if this.s1 is a null then will gets executed
   if argument.s1 is also null return true, if not return false.
   if this.s1 is not a null argument.s1 is a null then return false
   otherwise if argument.s1 is not a null it will compare the content 
   of this.s1 and argument.s1.

2. in any way we wont be getting null pointer exception. 
   this is the proper way of overriding equals method.

*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 27</h3>
<pre class="prettyprint linenums">
//equals method
class K
{
	int i;
}
class M9
{
	public static void main(String[] args) 
	{
		K k1 = new K();
		k1.i = 10;

		K k2 = new K();
		k2.i = 10;

		System.out.println(k1 == k2);
		System.out.println(k1.equals(k2));

		K k3 = k1;

		System.out.println(k3 == k1);
		System.out.println(k3.equals(k1));
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<br />
<article class="topic app">
<h2>app3</h2>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 28</h3>
<pre class="prettyprint linenums">
class A
{
	int i;
	A(int i)
	{
		this.i = i;
	}
}
class M1 
{
	public static void main(String[] args) 
	{
		A a1 = new A(90);
		A a2 = new A(90);
		System.out.println("a1: " + a1.hashCode());
		System.out.println("a2: " + a2.hashCode());
		A a3 = a1;
		System.out.println("a3: " + a3.hashCode());

	}
}
/*
a1 and a3
reference are pointing to the same object. a1 and a3 hashcode
are same. here hashcode is not generating based on the i value.
a1 and a2 hashcode are different but a1 and a2 i value is same.
hashcode method returning the memory address in the form of a
integer. hashcode method return type is int, it is returning
integer representation of memory address. hashcode doesnt care 
about the content of the object and i value. a1.i is same as
a2.i but we are getting different memory address.a1 and a3 are
pointing to same object thats why same memory address.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 29</h3>
<pre class="prettyprint linenums">
import java.util.HashSet;
class E
{
	int i, j, k;

	E(int i, int j, int k)
	{
		this.i = i;
		this.j = j;
		this.k = k;
	}

	public String toString()
	{
		return "(" + i + "," + j + "," + k + ")";
	}

	public boolean equals(Object obj)
	{
		boolean b1 = (i == ((E)obj).i) && (j == ((E)obj).j) && (k == ((E)obj).k);
		System.out.println("equal between" + this + " and " + obj + " is " + b1);
		return b1;
	}

	public int hashCode()
	{
		int hash = Integer.toString(i).hashCode();
		hash += Integer.toString(j).hashCode();
		hash += Integer.toString(k).hashCode();
		System.out.println("hashCode of " + this + " is " + hash);
		return hash;
	}
}
class M10 
{
	public static void main(String[] args) 
	{
		E e1 = new E(900, 100, 500);
		E e2 = new E(900, 100, 500);
		E e3 = new E(100, 100, 900);
		E e4 = new E(100, 100, 900);
		E e5 = new E(900, 500, 100);
		E e6 = new E(900, 500, 100);
		E e7 = new E(900, 700, 800);
		E e8 = new E(900, 800, 700);
		E e9 = new E(700, 900, 800);
		E e10 = new E(1900, 1100, 1500);
		
		HashSet<E> set = new HashSet<E>();

		set.add(e1);
		System.out.println("--11--");
		set.add(e2);
		System.out.println("--12--");
		set.add(e3);
		System.out.println("--13--");
		set.add(e4);
		System.out.println("--14--");
		set.add(e5);
		System.out.println("--15--");
		set.add(e6);
		System.out.println("--16--");
		set.add(e7);
		System.out.println("--17--");
		set.add(e8);
		System.out.println("--18--");
		set.add(e9);
		System.out.println("--19--");
		set.add(e10);
		System.out.println("--1010--");
		System.out.println(set);
	}
}
/*
what collection api doing internally while identifying duplicates. It is 
maintaining different buckets. to identify duplicates it is
maintaining hashbuckets. it is only calling hashcode
method getting a hash number choosing one bucket for that hash
number storing the first element inside that bucket. So first
element no need of comparing with other elements to avoid the
duplicate, for the first element it doesnt required to check the
duplicates because of its only one element. For the first element
calling hashcode method and getting hash number and that hash
number is allocating to one bucket, storing first element in that
bucket. That bucket is labeled with hash number. while addding
second element e2 again calling hashcode method getting hash
number, checking whether is there any bucket allocated for this
hash number. So already bucket is allocated for the same hash
number, for second element also we will be getting same hash
number. In the same bucket it suppose to store. Now it will be
calling equals method on first element and second element why
because already one element there in the bucket, these elements
are might be duplicate or may not be, so that is why equals 
method is calling between e2 and e1, then equals method returning
a true. If equals method returning a true both are same. e2 is
not adding only e1 is adding succesfuly. e2 is a duplicate to e1
.while adding e3 again it is calling hashcode method, definately
we will be getting a different hash number, so if it is a
different hash number a new bucket is choosing for the new bucket
current hash number is labeling. The third element e3 successfuly
stored in the second bucket. That second bucket is labeled with a
new hash number. So e3 added successfully. while adding e4
again calling hashcode method getting a hash number this hash
number is already allocated to second bucket. Now it is calling
equals method to know whether both are same of different. equals
method is calling between e3 and e4, content wise it is same so
it returns true. Both are same. if equals method returning true
e4 method is not adding. e5 is calling hashcode and e5 is same
hash number of first bucket. This e5 element has to compare with
the first bucket e1 element. Then equals method is calling equals
method comparing attribute by attrubute and we get a false. I,e 
e5 is not same as e1, Then e5 also storing in the first bucket.
first bucket contains 2 elements and second bucket
contains 1 element. Then e6 same hash number same bucket,
already in first bucket two elements are there. So e6 compare
with both, it is comparing first e1 and then only comparing with
e5, in one bucket while storing multiple elements the order will
be maintaining in that bucket. That order is maintaining through
linked list structure. Now e6 should be compared with e1 while
comparing we get false. Then e6 should not add straight away e6
should compared with e5 also because e5 is also there in the same
bucket. e5 and e6 both are calling through equals method. e5 and
e6 both are same returning true. for e7 we
get different hash number and third bucket is allocating, there
is no need to call the equal method, equal method is calling in a
bucket where already some elements are there in the bucket. so it
is a new bucket and doesnt requred to bother about storing
element in the new bucket. e8 is having the same hash number 
of third bucket. but in third bucket already one element is there
and calling equals method. equals method returning false, storing
in the third bucket. e9 is having the same hash number and
going with the third bucket. in the third bucket already two
elements are there. Calling equals method on the first element
getting false. Calling equals method on the second element
getting false. In the third bucket this element is adding
successfuly. e10 has entirely new hash number and choosing
different bucket and in the fourth bucket e10 element will be
stored.

A hashcode is a number generated from any object. This is what
allows objects to be stored/retrieved quickly in a Hashtable.
Imagine the following simple example:
On the table in front of you you have nine boxes, each marked
with a number 1 to 9. You also have a pile of wildly different
objects to store in these boxes, but once they are in there you
need to be able to find them as quickly as possible.
What you need is a way of instantly deciding which box you have
put each object in. It works like an index; you decide to find
the cabbage so you look up which box the cabbage is in, then go
straight to that box to get it.
Now imagine that you don't want to bother with the index, you
want to be able to find out immediately from the object which box
it lives in.
In the example, let's use a really simple way of doing this - the
number of letters in the name of the object. So the cabbage goes
in box 7, the pea goes in box 3, the rocket in box 6, the banjo
in box 5 and so on. What about the rhinoceros, though? It has 10
characters, so we'll change our algorithm a little and "wrap
round" so that 10-letter objects go in box 1, 11 letters in box 2
and so on. That should cover any object.
Sometimes a box will have more than one object in it, but if you
are looking for a rocket, it's still much quicker to compare a
peanut and a rocket, than to check a whole pile of cabbages, peas
, banjos and rhinoceroses.
That's a hash code. A way of getting a number from an object so
it can be stored in a Hashtable. In Java a hash code can be any
integer, and each object type is responsible for generating its
own. Lookup the "hashCode" method of Object.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 30</h3>
<pre class="prettyprint linenums">
class B
{
	int i;
	int j;

	B(int i, int j)
	{
		this.i = i;
		this.j = j;
	}
}
class M2 
{
	public static void main(String[] args) 
	{
		B b1 = new B(90, 10);
		B b2 = new B(90, 10);
		B b3 = b2;
		System.out.println(b1.hashCode());
		System.out.println(b2.hashCode());
		System.out.println(b3.hashCode());

	}
}
/*
b3 and b2 are
pointing to the same object. we dont want memory address
always try to do something based on the content or
state(attribute values). we can override hashCode method.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 31</h3>
<pre class="prettyprint linenums">
class C
{
	int i;

	C()
	{
		this.i = i;
	}

	public int hashCode()
	{
		return i;
	}
}
class M3 
{
	public static void main(String[] args) 
	{
		C c1 = new C();
		c1.i = 10;
		
		C c2 = new C();
		c2.i = 10;

		System.out.println(c1.hashCode());
		System.out.println(c2.hashCode());
	}
}
/*
overriding
hashcode method based on content it is returning int value.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 32</h3>
<pre class="prettyprint linenums">
class M4 
{
	public static void main(String[] args) 
	{
		String s1 = "hello";
		String s2 = "hello";
		String s3 = new String("hello");
		System.out.println(s1.hashCode());
		System.out.println(s2.hashCode());
		System.out.println(s3.hashCode());
		System.out.println(s1 == s2);
		System.out.println(s1 == s3);
		System.out.println(s2 == s3);
		System.out.println(s1.equals(s2));
		System.out.println(s2.equals(s3));
		System.out.println(s1.equals(s3));
	}
}
/*
inside String
class hashcode is already overrided, based on the content it is
returning int value.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 33</h3>
<pre class="prettyprint linenums">
class M5 
{
	public static void main(String[] args) 
	{
		StringBuffer s1 = new StringBuffer("hello");
		StringBuffer s2 = new StringBuffer("hello");
		System.out.println(s1.hashCode());
		System.out.println(s2.hashCode());
	}
}
/*
in StringBuffer class hashcode method is not overrided. even though content is
same we getting different number. in StringBuffer and StringBuilder only toString method got overrided and not equal
and hashcode methods.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 34</h3>
<pre class="prettyprint linenums">
class M6 
{
	public static void main(String[] args) 
	{
		StringBuilder s1 = new StringBuilder("hello");
		StringBuilder s2 = new StringBuilder("hello");
		System.out.println(s1.hashCode());
		System.out.println(s2.hashCode());
	}
}
/*
in StringBuffer
and StringBuilder only toString method got overrided and not
equal and hashcode methods
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 35</h3>
<pre class="prettyprint linenums">
class M7 
{
	@SuppressWarnings("removal")
	public static void main(String[] args) 
	{
		Integer obj1 = 100;
		Integer obj2 = new Integer(100);
		Character obj3 = 'a';
		Character obj4 = new Character('a');
		Boolean obj5 = true;
		Boolean obj6 = new Boolean(false);
		Double obj7 = 10.0;
		Double obj8 = new Double(10.0);
		Float obj9 = 20.0f;
		Float obj10 = new Float(20.0f);
		Byte obj11 = 20;
		Byte obj12 = new Byte((byte)20);
		Short obj13 = 30;
		Short obj14 = new Short((short)30);
		Long obj15 = 40l;
		Long obj16 = new Long(40l);
		System.out.println(obj1.hashCode());
		System.out.println(obj2.hashCode());
		System.out.println(obj3.hashCode());
		System.out.println(obj4.hashCode());
		System.out.println(obj5.hashCode());
		System.out.println(obj6.hashCode());
		System.out.println(obj7.hashCode());
		System.out.println(obj8.hashCode());
		System.out.println(obj9.hashCode());
		System.out.println(obj10.hashCode());
		System.out.println(obj11.hashCode());
		System.out.println(obj12.hashCode());
		System.out.println(obj13.hashCode());
		System.out.println(obj14.hashCode());
		System.out.println(obj15.hashCode());
		System.out.println(obj16.hashCode());
	}
}
/*
in every
wrapper class hashcode method got overrided and returning same
value not an address. in String, Wrapper, Collection classes
toString(), equals(), hashcode() overrided. in StringBuffer and 
StringBuilder class only toString() got overrided not the
hashCode() and equals().
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 36</h3>
<pre class="prettyprint linenums">
import java.util.ArrayList;
class M8 
{
	public static void main(String[] args) 
	{
		ArrayList<String> list1 = new ArrayList<String>();
		list1.add("hello1");
		list1.add("hello2");
		list1.add("hello3");

		ArrayList<String> list2 = new ArrayList<String>();
		list2.add("hello1");
		list2.add("hello2");
		list2.add("hello3");

		System.out.println(list1.hashCode());
		System.out.println(list2.hashCode());
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 37</h3>
<pre class="prettyprint linenums">
class D
{
	int i, j;

	D(int i, int j)
	{
		this.i = i;
		this.j = j;
	}

	public int hashCode()
	{
		String s1 = Integer.toString(i);
		String s2 = Integer.toString(j);
		int hash = s1.hashCode();
		System.out.println(s1.hashCode() + ", "  + s2.hashCode());
		hash += s2.hashCode();
		System.out.println("final hashcode is: " + hash);
		return hash;
	}
}
class M9
{
	public static void main(String[] args) 
	{
		D d1 = new D(10, 20);
		D d2 = new D(10, 20);
		System.out.println(d1.hashCode());
		System.out.println(d2.hashCode());
		D d3 = new D(20, 10);
		System.out.println(d3.hashCode());
		D d4 = new D(200, 100);
		System.out.println(d4.hashCode());
	}
}
/*
Object class
equals method evaluating two references. Object class hascode
method we can can evaluated two objects addresses. we dont want
object class hashcode and equals method, instead we can override
object class hashcode and equals method mainly to compare two
objects content sun people developed hashcode and equals method
for comparision purpose generaly both are related to memory 
hashcode method returns memeory address and equals method also
related to memeory only that it is checking both references are
pointing to same object or different object both methods we are
using for evaluation purpose, one object identifying equality
with other object in case of hashcode no if block at all if
any derived attribute is there then only we required if block.
incase of equals method lot of if block and lot boolean
expressions and it will take more time. definately equals
method taking more time than hashcode method. hashcode method
doesnt have any boolean expressions,it is only having caluculations.
d4 giving different hash number because content is varying d1
,d2,d3 giving same hash numbers advantage is very good
performance but disadvantage is not accurate  d1 and d2 both
are same then hash number also same, but d1 and d3 are different
but hashcode is same, d1 and d4 both are different and hash
number also diferent so it is causing confusion, ex: assume we 
have two persons and we should compare first person weight should
be compared with second person weight only and first person
height should be compared with second person height only but not
like first person height compared with second person weight. Its
not meaningful if two objects hashcodes are same we cannont
confirm whether they are same or not, we get confusion because d1
and d2 are same hash number and content also same but d1 and d3
hash number are same but the content is diferent so we can
confirm like, if two objects hash number is different then
content will be different. if two objects hash number is same
then we cant be sure that they are same. so limitation is
unable to find equality but it is perfect in case of inequality.
so use hashcode only in case of inequal and dont rely on two
objects same hash number. dont consider equality in case of
hashcode but consider inequality for utimate performance
consider inequality of hash number but for equality purpose dont
use the hashcode. in case of unavoidable scenario go for equals
method that, two objects with the same hashcode. if two objects 
hash number same then call equals method, if equals method
returns true both are same if it returns false both are
different. But dont call equals method in the without second
thought because equals method taking more time but it is giving
accurate result everytime because it is comparing attribute by
attribute and giving accurate results. first we are converting
i and j value to string and calling hashcode. sum of s1 hashcode
and s2 hash code we are returning. performace wise hashcode
method is faster than equals method.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<br />
<article class="topic app">
<h2>app4</h2>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 38</h3>
<pre class="prettyprint linenums">
//finalize method
class A
{
	//@SuppressWarnings("removal")
	protected void finalize() throws Throwable
	{
		System.out.println("from finalize");
	}
}
//@Deprecated
class M1 
{
	//@SuppressWarnings("deprecation")
	//@SuppressWarnings("removal")
	//@SuppressWarnings("unused")
	@SuppressWarnings({"unused", "deprecation", "removal"})
	public static void main(String[] args) 
	{
		A a1 = new A();
		a1 = null;
		System.out.println("end of the program");
	}
}
/*
-finalize() method also is an object class method.
-if an object contains minimum one reference then that object is live object.
-one object can have any no. of references.
-if no reference are there for an object then that object becomes abandoned object.
-resurrected(restore (a dead person) to life.) - 
-resurrected object - if the dead or abandoned object gets a reference some how that type of 
object we call it as resurrected object.
-once the object becomes abandoned then it is eligible for garbage collection.
abandoned objects we can also call as garbage objects.
- once object becomes garbage object, in java there is one thread called
garbage collector it is a internal demon thread once in a while
going to the heap to check any abandoned objects are there if
there call finalize method on abandoned object, check whether if
it is still abandoned or not, if still abandoned then remove from
the memory.
- demon thread is a thread which is depending on
parent thread life. memory management is taken care by garbage
collector.
- when gc removing objects from the memory that is
uncertain. We cant tell at which moment object will removed by
the garbage collector, garbage collector coming to the memory
once in a while
-in the above program even though the object
becomes abandoned when we execute the program finalize method
wont be executed even though we have overrided in our class, why
because the total execution is getting over by the time of
garbage collector coming to the heap memory.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 39</h3>
<pre class="prettyprint linenums">
class B
{
	protected void finalize() throws Throwable
	{
		System.out.println("from finalize");
	}
}
class M2 
{
	public static void main(String[] args) 
	{
		B b1 = new B();
		b1 = null;
		System.gc();
		//Runtime.getRuntime().gc();
		System.out.println("end of the program");
	}
}
/*
- there is a way of 
calling garbage collector to scan the heap memory and remove the
abandoned object that is by making a request to the gc
- there are two ways to make the request
System.gc();
//Runtime.getRuntime().gc();
-demon thread is
background thread and user thread is forground thread that serves
customer requirements
-
-
-
-----
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 40</h3>
<pre class="prettyprint linenums">
class Util
{
	static void sleep(long millis)
	{
		try
		{
			Thread.sleep(millis);
		}
		catch (InterruptedException ex)
		{
			ex.printStackTrace();
		}
	}
}
class C
{
	static C obj;
	protected void finalize() throws Throwable
	{
		obj = this;
		System.out.println("from finalize");
	}
}
class M3 
{
	public static void main(String[] args) 
	{
		C c1 = new C();
		System.out.println(1 + ":" + c1);
		System.out.println(2 + ":" + C.obj);
		Util.sleep(1000);
		c1 = null;
		System.gc();
		Util.sleep(1000);
		System.out.println(3 + ":" + c1);
		System.out.println(4 + ":" + C.obj);
		C.obj = null;
		Util.sleep(1000);
		System.gc();
		System.out.println(5 + ":" + c1);
		System.out.println(6 + ":" + C.obj);
		System.out.println("end");
	}
}
/*
class C containing one static type
attribute, you can access this by using class name.  c1
pointing to an object. obj is null. one second sleep.
making first object that is a1 pointing object abandoned.
.making a request to garbage collector.main thread
is sleeping for one second.somehow abandoned object
assigning to obj.current object assigning to obj. gc
suppose to remove one abandoned object, at last step finalize
method is executing.inside a finalize method this i,e
current object, which object is about to be garbage collected,
that object assigned to obj, obj is a reference variable. While
executing a finalize method object is getting life. we
made a request to garbage collector, garbage collector called
finalize method. while calling the finalize method somehow object
got the reference. Now this object becomes as a resurructed
object.c1 will be null. wherever c1 was pointing
for the same object obj pointing now. from the resurructed
object we removed reference variable, so now resurructed object
become abandoned.sleeping for one second.calling 
gc.if resurructed object becoming abandoned, then straight away
removing that object without calling finalize method.on any
object finalize method calling only one time.if at all
resurructed object becoming abandoned then removing that object
straight away without calling finalize method
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<br />
<article class="topic app">
<h2>app5</h2>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 41</h3>
<pre class="prettyprint linenums">
//clone method
/*
Original object can be copied through a clone operation. And
Making a duplicate object through clone. object class contains
built in cloning operation. There is a clone method inside object
class. we can copy the content into another place without a
constructor execution. Somehow run time environment creating the
new object from the original copied object content. if we try
to do object cloning manually, it takes lot of time and effort
because consider if an object contains 100s of attribute and the
first step we need to create that object with those 100s
attribute and then create a new object and copy all the
attributes to that newly created object, instead of this lenghty
process we can go for object class clone method return a 
duplicate object, copied object, but to use the object class
clone method we need to follow some conditions, straight away
object class clone method cannot be used. so in case of cloning
security issues for ex: if we have a two keys to the lock for our
home we need to keep both the keys safely.
*/
class A 
{
}
class M1 extends A
{
	public static void main(String[] args) 
	{
		A a1 = new A();
		A a2 =  a1.clone();
		System.out.println("Hello World!");
	}
}
/*
- clone method is a protected method in the object class.
then it has to use in the subclass only. A class clone
should use in the A only. M1 also subclass to object. M1 also
containing a clone. M1 class clone should be used in M1 itself and A
class clone should use in A iteself. protected methods only 
serve to the current subclass.
This is the first condition

-clone method is not developed
for any one class purpose like this A class. clone method is
developed for any type of the classes. clone method return type
is Object type. even though it is A type it is returning A
Object, it is returning in the form of a Object type. We need to
down cast, here we are not down casting.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 42</h3>
<pre class="prettyprint linenums">
class B
{
	public static void main(String[] args) 
	{
		B b1 = new B();
		B b2 = (B) b1.clone();//downcasting return value of clone method to B type 
		System.out.println("done");
	}
}
/*
clone method is a checked exception type of statement to clone not
supported exception we require either try,catch or throws with
a clone not supported exception.*/

</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 43</h3>
<pre class="prettyprint linenums">
class C
{
	public static void main(String[] args) throws CloneNotSupportedException
	{
		C c1 = new C();
		System.out.println("1");
		C c2 = (C) c1.clone();//downcasting return value of clone method to C type 
		System.out.println("2");
		System.out.println("done");
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 44</h3>
<pre class="prettyprint linenums">
class D implements Cloneable
{
	public static void main(String[] args) throws CloneNotSupportedException
	{
		D d1 = new D();
		D d2 = (D) d1.clone();//downcasting return value of clone method to D type 
		System.out.println("d1: " + d1);
		System.out.println("d2: " + d2);
		System.out.println("done");
	}
}
/*
successful.
Clonable is an interface. Available in java.lang package, its a
marker interface. marker interface: an interface doesnt have any
members, an empty interface. It is only providing mark, providing
a type. D is a type of clonable, and all the clonable type are
allowing cloning operation. in order to specify something to the
runtime environment make the class as cloneable, so that allowing
the cloning operation. 
if object is type of cloneable then it is eligible for cloning operation.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 45</h3>
<pre class="prettyprint linenums">
class G implements Cloneable
{
	int i;

	public static void main(String[] args) throws CloneNotSupportedException
	{
		G obj1 = new G();
		obj1.i = 10;
		G obj2 = (G) obj1.clone();//downcasting return value of clone method to D type 
		System.out.println("a: " + obj2.i);
		obj2.i = 20;
		System.out.println("b: " + obj1.i);
		obj1.i = 30;
		System.out.println("c: " + obj2.i);
		System.out.println("d: " + obj1.i);
	}
}
/*
while cloning data of the original object copied into cloned object. After that
the changes are independent. I,e if we do change in the original
that will not be reflecting to duplicate and, if we do change in
the duplicate that is also not reflecting to the original object. Both
are independent objects. after cloning operation, both are
independent objects. throgh cloning we got the duplicate,
duplicate is a independent of original, changes in the original 
not reflecting back to duplicate, changes in the duplicate not
reflecting back to original. this type of cloning operation we call it as a
deep copy operation, why because no link between original and
duplicate. changes in the original not reflecting back to
duplicate, changes in the duplicate not reflecting back to
original. That is why it is called deep copy operation. object
class clone method providing a deep copy operation. changes in
the original not reflecting back to duplicate, changes in the
duplicate not reflecting back to original.
The opposite to deep copy operation is shallow copy operation
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 46</h3>
<pre class="prettyprint linenums">
class H
{
	int x;
}
class I implements Cloneable
{
	H h1;

	public static void main(String[] args) throws CloneNotSupportedException
	{
		I obj1 = new I();
		obj1.h1 = new H();

		System.out.println(obj1.h1.x);

		obj1.h1.x = 10;

		I obj2 = (I) obj1.clone();
		
		System.out.println(1 + ":" + obj2.h1.x);//10
		obj1.h1.x = 20;
		System.out.println(2 + ":" + obj2.h1.x);//20
		obj2.h1.x = 30;
		System.out.println(3 + ":" + obj1.h1.x);//30
	}
}
/*
shallow copy
operation, if any derived attributes are there.this program
performing shallow copy, if there is any derived attributes are
there we will be getting shallow copy thruogh object class clone
method. I class having only one attribute that is H type. if 
class containing derived datatype, then you will be getting a
shallow copy operation. object class clone method providing
shallow copy. Shallow copy means changes in one reflecting to
another. if attributes are primitive deep copy. If attributes
are derived then shallow copy.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<br />
<article class="topic app">
<h2>app6</h2>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 47</h3>
<pre class="prettyprint linenums">
//reflection api
class A 
{
}
class M1
{
	public static void main(String[] args) 
	{
		//A a1 = new A();
		Class c1 = new A().getClass();
		System.out.println(c1.getName());
	}
}
/*

java.lang
----------
1. Object
2. Class 

class Object
{
	//statements
}

class Class
{
	//statements
}

1. for class Class object will be created while 
   calling getClass() method of object class.
2. Object class members are available in every object.
3. Among all the members of Object class there is a getClass() method also.
4. while calling getClass() method it returns an object to the particular class.
   Inside this Class there are several getter methods. Through this getter methods we
   can identify what are the attributes, what are the methods and what is the class name,
   Constructors, access levels like several getter methods are there.
5. Depending on the requirement we can identify which getter method
   we require. to know the schema of a class, to which object is
   created just call getClass() method. it returns an object to the
   Class inside the class several getter methods are available. To
   know every information about a class to which an object is created.
6. Reflection API  
   generally class to object. Now object to class.
   Reflecting class information through an object. 
7. In any general object there is a getClass() method and you will be getting
   Class object. That object contains several getter methods.
8. By using those getter methods we can find out every information about
   object which class is defined.
9. we are getting a detailed output. assume somehow we got an
   object, just call getClass() method. we will be getting a Class
   object. That Class object containing every information about a
   class to which object is created.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 48</h3>
<pre class="prettyprint linenums">
import java.lang.reflect.Method;
class K
{
	void test2(String s1)
	{
		System.out.println("from test2:" + s1);
	}
}
class M10 
{
	public static void main(String[] args) throws Exception
	{
		Class c1 = Class.forName("K");
		Object obj = c1.newInstance();	
		
		Method m2 = c1.getDeclaredMethod("test2", String.class);
		m2.invoke(obj, "hello");

		System.out.println();
	}
}
/*
1. How to call test2 method?
2. test2 method is taking one string argument.
   While defining a method object, supply name of the method and supply
   argument datatype. While calling a method on obj supply the argument.
3. while getting m1 we are simply suppying test1, without any datatypes.
   While getting m2, supplying test2 and string Datatype, and we called by supplying 
   m1.invoke(obj, "hello");
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 49</h3>
<pre class="prettyprint linenums">
import java.lang.reflect.Method;
class L
{
	void test3(String s1)
	{
		System.out.println("from test3:" + s1);
	}
	void test3(String s1, int i, double j)
	{
		System.out.println("from test3:" + s1 + "," + i + "," + j);
	}
}
class M11
{
	public static void main(String[] args) throws Exception
	{	
		Class c1 = Class.forName("L");
		Object obj = c1.newInstance();	
		
		Method m1 = c1.getDeclaredMethod("test3", String.class);
		Method m2 = c1.getDeclaredMethod("test3", String.class, int.class, double.class);
		m1.invoke(obj, "hello");
		m2.invoke(obj, "hello", 30, 4.5);
	}
}
/*
1. developing one more method which accepts multiple arguments
2. in the same L class we develop multiple test3 methods, that is by overloading,
   by changing number of arguments or datatype. 
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 50</h3>
<pre class="prettyprint linenums">
import java.lang.reflect.Method;
class M
{
	int test4()
	{
		System.out.println("from test4");
		return 1111;
	}
}
class M12
{
	public static void main(String[] args) throws Exception
	{
		Class c1 = Class.forName("M");
		Object obj = c1.newInstance();	
		Method m4 = c1.getDeclaredMethod("test4");
		//Object value = m4.invoke(obj);
		Integer value = (Integer)m4.invoke(obj);
		System.out.println(value);
	}
}
/*
1. test4 method having return type int that is returning int value.
   How to call test4 method through reflection api??
2. invoke method returning a value, whatever test4 returning a
   value that value returning into object type value. If we wanted
   we can also downcast into Integer type also. Methods may have a 
   different return type. invoke method is a generic for all the
   methods. That is why return type is object. we can downcast if we
   wanted.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 51</h3>
<pre class="prettyprint linenums">
import java.lang.reflect.Method;
import java.lang.reflect.Constructor;
class N
{
	N()
	{
		System.out.println("N()");
	}

	N(int i)
	{
		System.out.println("N(int)");
	}

	int test4()
	{
		System.out.println("from test4");
		return 1111;
	}
}
class M13
{
	public static void main(String[] args) throws Exception
	{
		Class c1 = Class.forName("N");
		//Creates a new instance of the class represented by this Class object.
		Object obj = c1.newInstance();	
		Method m4 = c1.getDeclaredMethod("test4");
		Object value = m4.invoke(obj);
		System.out.println(value);
		System.out.println();
		Constructor[] constructors = c1.getDeclaredConstructors();
		for (Constructor cons : constructors)
		{
			System.out.println(cons);
		}
	}
}
/*
1. reflection api demands no arguments constructor, if at
   all we want to use newinstance method. newinstance method is
   always using no argument constructor to create an object to
   specified class.
2. we are using reflection api to create an object to N.
   We are supplying class name in the form of a string.
   if it is so, N class should be having no arg constructor.
   Reflection api always uses no argument constructor internaly.
   We are not creating an object, we are calling newinstace method. in
   the body of the new instance method it is using no argument
   constructor. If at all somehow no argument constructor not there
   we will be getting instantiation exception. 
3. explicitly we given the no arg constructor.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 52</h3>
<pre class="prettyprint linenums">
import java.lang.reflect.Field;
class C 
{
	int param1;
	String firstName;
}
class M2
{
	public static void main(String[] args) 
	{
		C obj = new C();
		Class c1 = obj.getClass();
		System.out.println(c1.getName());
		Field[] fields = c1.getDeclaredFields();
		for(Field field : fields)
		{
			System.out.println(field.getName());
			System.out.println(field.getType());
			System.out.println("----------------");
		}
	}
}
/*
we are able to know name of the attribute and its datatype*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 53</h3>
<pre class="prettyprint linenums">
import java.lang.reflect.Field;
class B
{
	int i;
	double j;
	boolean k;
	char l;
	byte m;
}
class D
{
	int param1;
	String firstName;
}
class M3
{
	public static void main(String[] args) 
	{
		Object obj = new B();
		test(obj);
	}

	static void test(Object obj)
	{
		Class c1 = obj.getClass();
		System.out.println(c1.getName());
		Field[] fields = c1.getDeclaredFields();
		for(Field field : fields)
		{
			System.out.println(field.getName());
			System.out.println(field.getType());
			System.out.println("----------------");
		}
	}
}
/*
1. somebody is calling test method, and we are the developer of test() method.
   for the test method and we are getting an object. and we dont know to which class object
   is created.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 54</h3>
<pre class="prettyprint linenums">
import java.lang.reflect.Method;
class E
{
	void test1()
	{

	}
	int test2()
	{
		return 200;
	}
	String test3()
	{
		return "hello";
	}
}
class M4
{
	public static void main(String[] args) 
	{
		Object a1 = new E();
		//String s1 = "hello";
		//Integer i1 = 200;
		info(a1);
		//System.out.println("****************************");
		//info(s1);
		//System.out.println("****************************");
		//info(obj);
	}
	static void info(Object obj)
	{
		Class c1 = obj.getClass();
		Method[] methods = c1.getDeclaredMethods();//c1.getMethods();
		for(Method method : methods)
		{
			System.out.println(method.getName() + "::" + method.getReturnType());
		}
	}
}
/*
1. There are several getter methods in the Class and we used few methods.
   depending on our requirement we can choose which getter method is suitable.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 55</h3>
<pre class="prettyprint linenums">
class F
{
	static 
	{
		System.out.println("SIB");
	}
}
class M5 
{
	public static void main(String[] args) 
	{
		F f1 = new F();
		System.out.println("done");
	}
}
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 56</h3>
<pre class="prettyprint linenums">
class G
{
	static 
	{
		System.out.println("SIB");
	}
}
class M6
{
	public static void main(String[] args) throws ClassNotFoundException 
	{
		//G a1 = new G();
		Class c1 = Class.forName("G");
		
		System.out.println("done");
	}
}
/*
1. we LNO.13 - we are supplying class name in the form of a string. we are loading the class
   explicitely vis Class.forName.
2. if class is not loaded yet, we can load it by using Class.forName by specifying the class name
   in the form of a string.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 57</h3>
<pre class="prettyprint linenums">
class H
{
	static 
	{
		System.out.println("SIB");
	}
}
class M7
{
	public static void main(String[] args) throws ClassNotFoundException 
	{
		H a1 = new H();

		Class c1 = Class.forName("H");
		
		System.out.println("done");
	}
}
/*
1. if the class is already loaded it wont load one more time. any class will be loading to the 
   memory only one time
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 58</h3>
<pre class="prettyprint linenums">
class I
{
	static 
	{
		System.out.println("SIB");
	}
}
class M8
{
	public static void main(String[] args) throws ClassNotFoundException 
	{
		I a1 = new I();
		Class obj1 = a1.getClass();
		Class obj2 = Class.forName("I");		
		//System.out.println(a1 == obj1);
		//System.out.println(a1 == obj2);
		System.out.println(obj1 == obj2);
		//System.out.println(a1.hashCode());
		System.out.println(obj1.hashCode());
		System.out.println(obj2.hashCode());
		//System.out.println("done");
	}
}
/*
1. whenever class is loading to the memory (I class) at that time Class object is created
   only one object is created.
2. That object reference returning to obj1 and same reference returning to obj2.
3. sometimes we require to manage a class through a string, class name is in one file.
   reading the class name into java program, that class name available inside a string,
   as a string object.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>
<article class="topic">
<h3 class="topic-title" id="introduction">Example No. 59</h3>
<pre class="prettyprint linenums">
import java.lang.reflect.Field;
import java.lang.reflect.Method;
class J
{
	int i;
	void test1()
	{
		System.out.println("from test");
	}
}
class M9
{
	public static void main(String[] args) throws Exception
	{
		Class c1 = Class.forName("J");
		Object obj = c1.newInstance();
		Field f1 = c1.getDeclaredField("i");
		f1.setInt(obj, 20);
		//J j1 = new J();
		//j1.i = 20;
		Method m1 = c1.getDeclaredMethod("test1");
		m1.invoke(obj);
		//j1.test1();
		System.out.println(f1.getInt(obj));
	}
}
/*

1. Class c1 = c1.forName("J"); - using class name in the form of string.
2. assume that we are reading this class name from the file system. and using this class
    through Class.forName. if the class is available run time environment load this class
	into the memory. 
3. whenever this class is loading to the memory object is created, then that object will be
   assigned to c1.
4. while using c1.newInstance, object is created to J class, this is another way of creating an
   object to that class(J).
5. c1 pointing to Class object whichever created to J class.
   while J loading to the memory one Class object is creating to J class,
   same is assigning to c1. Now c1 is a Class object to class J.
   Now If you call newinstance method you will get object to J,
   that object is assigned to obj. Obj pointing to J object.
   We are not using new operator and we are not using clone method.
   This is the third apporoach to create an object to any specified class.
   1 st  by using new operator straight away.
   2 nd  by using clone method.
   3 rd  by using reflection api newInstance method.
6. LNO: 17 we are finding out field object inside J class for the i.
   Inside a J class every information is there in the c1.
   c1 is a Class object to J. Through c1 we can call
   declared field. Supply name of the field in the form of string.
7. we got the field object which is refering to i, inside a J class.
8. f1.setInt(obj, 20); we need to set i value 20 in the obj pointing object.
   obj pointing object is a J object. f1 refering i. obj refering to J object.
   we wanted to set int value to i which is available in the obj.
9. f1.setInt(obj, 20); is similar to obj.i = 20 | in general we will be using
   reference[.]variable = 20 here, obj pointing to J object. f1 pointing to attribute i.
10. f1.setInt(obj, 20); 20 assigning to i. whatever i available in the obj that i modified to 20.
11. Method m1 = c1.getDeclaredMethod("test1"); in the J class there is a test1 method.
    by using c1 we can refere a test1 method.
12. m1.invoke(obj); on obj test1 method will be calling. obj pointing to J object.
    that J object containing i and test1, m1 refering to the test1()
13. System.out.println(f1.getInt(obj)); it is similar to System.out.println(obj.i);
    f1 refering to i
14. So the Output we get is from test
							20
15. we are using class name, attribute name, method name in the form of a string.
*/
</pre>
<br />
<pre class="output"><b>o/p: </b>
</pre>
<br />
<pre class="output"><b>Explanation: </b>
</pre>
</article>


		<!-- notes body start -->
		<main class="main">
			<section class="class-notes">
				<!-- <h2 class="subject-title">Subject Title</h2> -->

				<!-- Add more articles for other topics -->
			</section>
		</main>
		<!-- notes body end -->

		<!-- content-divider -->
		<div class="content-divider"></div>
		<!-- end of content divider -->
		<!-- footer section -->
		<footer class="footer">
			<div class="section-center">
				<div class="social-icons">
					<!-- social icon -->
					<a href="#" class="social-icon">
						<i class="fa-brands fa-square-facebook"></i>
					</a>
					<!-- social icon -->
					<a href="#" class="social-icon">
						<i class="fa-brands fa-square-twitter"></i>
					</a>
					<!-- social icon -->
					<a href="#" class="social-icon">
						<i class="fa-brands fa-square-instagram"></i>
					</a>
					<!-- end of social icon -->
				</div>
				<p class="footer-text">
					&copy;
					<span class="text-primary">vijays programming 2024</span>
					all rights reserved
				</p>
			</div>
		</footer>
		<script src="./app.js"></script>
		<script
			type="text/javascript"
			src="./google-code-prettify/prettify.js"
		></script>
	</body>
</html>

<!-- <span class="navbar-links">Notes Navigator</span>
        <br />
        <li><a href="#introduction" class="nav-link">Introduction</a></li>
        <li><a href="#object-class" class="nav-link">Object Class</a></li>
        <li><a href="#tostring" class="nav-link">toString() Method</a></li>
        <li>
          <a href="#hashcode" class="nav-link">hashCode() Method</a>
        </li>
        <li><a href="#equals" class="nav-link">equals() Method</a></li>
        <li><a href="#clone" class="nav-link">clone() Method</a></li>
        <li>
          <a href="#finalize" class="nav-link">finalize() Method</a>
        </li>
        <li><a href="#wait" class="nav-link">wait() Method</a></li>
        <li><a href="#notify" class="nav-link">notify() Method</a></li>
        <li>
          <a href="#notify-all" class="nav-link">notifyAll() Method </a>
        </li> -->
